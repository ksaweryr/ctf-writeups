# MathMAC
> ### Category: crypto
>
> Why using boring symmetric crypto for MACs when we can use fancy math?
>
> `nc mathmac.challs.open.ecsc2024.it 38013`
>
> ### Attachments
>
> `mathmac.py`
## Intial analysis
There are 2 options available in the menu (except for quitting the application):
1. Generate new random token
```py
if choice == 1:
    x = randint(0, 2**M-1)
    data.append(x)
    tag = mac.sign(x)
    print(f"{x},{tag}")
```
2. Verify a token (and get the flag if the token wasn't generated by the application)
```py
elif choice == 2:
    x, tag = input().strip().split(",")
    x = int(x)
    tag = int(tag)
    actual_tag = mac.sign(x)
    if actual_tag is None or tag != actual_tag:
        print("Unlucky")
        exit(1)

    if x in data:
        print("Yup. I know.")
    else:
        print(flag)
```
The algorithm for generating signatures is:
```py
class MAC:
    def __init__(self, n):
        self.p = 8636821143825786083
        self.n = n
        self.sk = [randint(0, self.p) for _ in range(n)]
        self.base = pow(4, randint(0, self.p), self.p)
    
    def sign(self, x):
        if x < 0 or x >= 2**self.n:
            return None
        x = list(map(int, bin(x)[2:].zfill(self.n)))
        assert len(x) == self.n
        res = self.base
        for ai, xi in zip(self.sk, x):
            if xi == 1:
                res = pow(res, ai, self.p)
        return res
```
where `n` is set to `64` in `main`:
```py
M = 64
mac = MAC(M)
```
The point of the challenge is therefore to forge a signature for a new token after seeing as many signatures as we want (with one restrictions - there's a 3-minute timeout after which the connection will be closed by the server).
## Analysing the signing algorithm
The signing algorithm is pretty straightforward, a signature of a number $n$ with bits at positions $i_0, i_1, ..., i_k$ set (i.e. $n = \sum_{j = 0}^k 2^{i_j}$) is a number $(4^B)^{\prod_{j = 0}^k sk_{i_j}} \mod p$ where $p = 8636821143825786083$ and $4^B$ is the base (see the source code). Since p is small (only 62 bits), it's possible to calculate the discrete logarithm of base 4 of any signature s over $GF(p)$ (that is, a number $a$ such that $4^a \equiv s \mod p$).
## What to do next?
A possible approach is to find 3 pairwise different numbers `a`, `b` and `c` with signatures `s1`, `s2` and `s3` such that `b & (a | c) = b` (every bit that's set in b is also set in a or c) and `(a & c) & b = (a & c)` (if a bit is set in both a and c, it is also set in b). That means that if we consider the numbers `a`, `b` and `c` to be lists of bits and "subtract" the bits of b from a (i.e. if `a = [1 0 1 0 1]` and `b = [0 1 1 0 1]`, a "subtraction" would be `a-b = [1 -1 0 0 0]`) and then "add" the bits of c to that result (e.g. take a-b from the previous example and let `c = [0 1 0 1 0]`, now `a-b+c = [1 0 0 1 0]`), we will always get a new list of only 0's and 1's - therefore, it corresponds to a new number (let's call it `d`) that is not equal to `a`, `b` or `c` - that number will in fact be equal to `(a & ~b) | (~(~a & b) & c)` (bits in `a` that are not in `b` and bits in `c` that are also not in `b` or are in `a`). Now if $s1 = 4^{B e_1}$, $s2 = 4^{B e_2}$ and $s3 = 4^{B e_1}$, we can calculate the signature `s4` for `d` which will be equal to $4^{(B e_1)(B e_2)^{-1}(B e_3)} = 4^{B e_1 e_2^{-1} e_3}$.
## How to calculate $e_2^{-1}$
It is known that $x^a \equiv x^b \mod p \iff a \equiv b \mod \phi(p)$ (where $\phi$ is the Euler's totient function), therefore $e_2 e_2^{-1} \equiv 1 \mod \phi(p)$. Since $p$ is prime, $\phi(p) = p - 1$. However a number $a$ is invertible modulo $m$ iff $gcd(a, m) = 1$. As in this case $m = p - 1$ must be even, it is very unlikely for $gcd(e_2, p - 1)$ to be $1$, because that would mean that $e_2$ must be odd. In that case, instead of calculating $e_2^{-1} \mod \phi(p)$ and raising $4^{B e_1}$ to that number, we can instead take $e_2th$ root of $4^{B e_1}$ modulo $p$ to get the desired result.
## Putting it all together
An implementation of this attack in SageMath is provided in the [solve.sage](./solve.sage) file. It usually needs to get between 300 and 1000 numbers before finding a suitable triple to perform the attack.
## Flag
`openECSC{l1n34r_4lg3br4_1n_7h3_3xp0n3n7!!_dda0ece9}`